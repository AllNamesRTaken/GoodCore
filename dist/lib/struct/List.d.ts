export declare class List<T> implements IList<T> {
    private _array;
    constructor(arr?: T[] | List<T>);
    readonly values: T[];
    get(pos: number): T;
    readonly count: number;
    clear(): List<T>;
    add(v: T): List<T>;
    insertAt(pos: number, v: T): List<T>;
    push(v: T): number;
    pop(): T;
    shift(): T;
    concat(v: T[] | List<T>): List<T>;
    append(v: T[] | List<T>): List<T>;
    copy(src: List<T> | T[]): List<T>;
    shallowCopy(src: List<T> | T[]): List<T>;
    clone(): List<T>;
    remove(v: T): List<T>;
    removeAt(n: number): List<T>;
    forEach(fn: (el: T, i?: number) => any): List<T>;
    until(test: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): List<T>;
    reverseForEach(fn: (el: T, i?: number) => any): List<T>;
    reverseUntil(test: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): List<T>;
    some(filter: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): List<T>;
    indexOf(v: T): number;
    contains(v: T): boolean;
    reverse(): List<T>;
    select(fn: (el: T, i?: number) => boolean): List<T>;
    selectInto(src: List<T> | T[], fn: (el: T, i?: number) => boolean): List<T>;
    orderBy(fn: (a: T, b: T) => number): List<T>;
    map<S>(fn: (el: T, i?: number) => S): List<S>;
    mapInto<S>(src: List<S> | S[], fn: (el: S, i?: number) => T): List<T>;
    reduce(fn: (acc: any, cur: T) => any, start?: any): any;
    equals(b: List<T>): boolean;
}
