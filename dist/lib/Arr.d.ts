export declare class _Array {
    private _int;
    constructor();
    flatten<T>(src: any[]): T[];
    private flattenInner<T>(src, result?);
    reverse<T>(array: T[]): T[];
    concat(...arrs: any[]): any[];
    slice<T>(src: T[], from?: number, count?: number): T[];
    append<T>(arr: T[], values: T[]): void;
    removeAt(arr: any[], index: number): void;
    indexOfElement(src: any[], el: any): number;
    remove(arr: any[], el: any): void;
    indexOf(src: any[], fn: (el: any) => boolean): number;
    removeOneByFn(arr: any[], fn: (el: any) => boolean): void;
    shallowCopy<T>(src: T[]): T[];
    shallowCopyInto<T>(src: T[], target: T[]): void;
    shallowFill<T>(src: T[], target: T[], at?: number): void;
    deepCopy<T>(src: T[]): T[];
    deepCopyInto<T>(src: T[], target: T[]): void;
    deepFill<T>(src: T[], target: T[], at?: number): void;
    filter<T>(src: T[], fn: (el: T, i?: number) => boolean): T[];
    filterInto<T>(src: T[], target: T[], fn: (el: T, i?: number) => boolean): void;
    map<S, T>(src: S[], fn: (el: S, i?: number) => T): T[];
    mapInto<S, T>(src: S[], target: T[], fn: (el: S, i?: number) => T): void;
    reduce<T>(src: T[], fn: (acc: any | number, cur: T) => any | number, start?: any | number): any | number;
    forEach<T>(src: T[], fn: (el: T, i?: number) => any): void;
    until<T>(src: T[], test: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    reverseForEach<T>(src: T[], fn: (el: T, i?: number) => any): void;
    reverseUntil<T>(src: T[], test: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    some<T>(src: T[], filter: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    insertAt<T>(src: T[], pos: number, v: T): void;
    binarySearch<T>(src: T[], cmp: (el: T) => number): number;
}
export declare let Arr: _Array;
