export declare class _Array {
    private _int;
    constructor();
    Flatten(src: any[]): any[];
    private FlattenInner(src, result?);
    Reverse(array: any[]): void;
    Concat(...arrs: any[]): any[];
    Slice<T>(src: T[], from?: number, count?: number): T[];
    Append<T>(arr: T[], values: T[]): void;
    RemoveOneAt(arr: any[], index: number): void;
    IndexOfElement(src: any[], el: any): number;
    RemoveOneByElement(arr: any[], el: any): void;
    IndexOf(src: any[], fn: (el: any) => boolean): number;
    RemoveOneByFn(arr: any[], fn: (el: any) => boolean): void;
    ShallowCopy<T>(src: T[]): T[];
    ShallowCopyInto<T>(src: T[], target: T[]): void;
    ShallowFill<T>(src: T[], target: T[], at?: number): void;
    DeepCopy<T>(src: T[]): T[];
    DeepCopyInto<T>(src: T[], target: T[]): void;
    DeepFill<T>(src: T[], target: T[], at?: number): void;
    Filter<T>(src: T[], fn: (el: T, i?: number) => boolean): T[];
    FilterInto<T>(src: T[], target: T[], fn: (el: T, i?: number) => boolean): void;
    Map<T>(src: T[], fn: (el: T, i?: number) => any): any[];
    MapInto<T>(src: any[], target: T[], fn: (el: T, i?: number) => T): void;
    Reduce<T>(src: T[], fn: (acc: any | number, cur: T) => any | number, start?: any | number): any | number;
    ForEach<T>(src: T[], fn: (el: T, i?: number) => any): void;
    Until<T>(src: T[], fn: (el: T, i?: number) => boolean): void;
    Some<T>(src: T[], filter: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    InsertAt<T>(src: T[], pos: number, v: T): void;
}
export declare let Arr: _Array;
