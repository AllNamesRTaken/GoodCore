export declare class Arr {
    constructor();
    static flatten<T>(src: any[]): T[];
    private static flattenInner<T>(src, result?);
    static reverse<T>(array: T[]): T[];
    static concat(...arrs: any[]): any[];
    static slice<T>(src: T[], from?: number, count?: number): T[];
    static append<T>(arr: T[], values: T[]): void;
    static removeAt(arr: any[], index: number): void;
    static indexOfElement(src: any[], el: any): number;
    static remove(arr: any[], el: any): void;
    static indexOf(src: any[], fn: (el: any) => boolean): number;
    static removeOneByFn(arr: any[], fn: (el: any) => boolean): void;
    static shallowCopy<T>(src: T[]): T[];
    static shallowCopyInto<T>(src: T[], target: T[]): void;
    static shallowFill<T>(src: T[], target: T[], at?: number): void;
    static deepCopy<T>(src: T[]): T[];
    static deepCopyInto<T>(src: T[], target: T[]): void;
    static deepFill<T>(src: T[], target: T[], at?: number): void;
    static filter<T>(src: T[], fn: (el: T, i?: number) => boolean): T[];
    static filterInto<T>(src: T[], target: T[], fn: (el: T, i?: number) => boolean): void;
    static map<S, T>(src: S[], fn: (el: S, i?: number) => T): T[];
    static mapInto<S, T>(src: S[], target: T[], fn: (el: S, i?: number) => T): void;
    static reduce<T>(src: T[], fn: (acc: any | number, cur: T) => any | number, start?: any | number): any | number;
    static forEach<T>(src: T[], fn: (el: T, i?: number) => any): void;
    static until<T>(src: T[], test: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    static reverseForEach<T>(src: T[], fn: (el: T, i?: number) => any): void;
    static reverseUntil<T>(src: T[], test: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    static some<T>(src: T[], filter: (el: T, i?: number) => boolean, fn: (el: T, i?: number) => any): void;
    static insertAt<T>(src: T[], pos: number, v: T): void;
    static binarySearch<T>(src: T[], cmp: (el: T) => number): number;
}
